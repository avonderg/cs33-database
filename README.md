# 8-database

On the server side of my program, following the structure of my main, I first block SIGPIPE, and then set up my sig_handler_constructor, which essentially creates a thread to handle SIGINT by calling monitor signal, which waits for a SIGINT signal to be sent to the server process, and then cancels all client threads when one arrives. Then, I call start_listener to create a listener thread which executes independently of the caller, and waits for incoming client connections. The listener thread executes client constructor, which creates a new client thread executing run_client. Within run_client, I first loop through the list of threads and insert the newly created client thread, increment the number of threads, and then create response and command buffers to process user commands. I push thread cleanup before processing commands, which essentially is a cleanup routine for client threads, removing a client object from the thread list once it disconnects, destroying the client struct, and signaling that it has finished. Following that, I enter the REPL and read input from the server side using a buffer. If a client enters the ’s’ command, I call client_control_stop, which stops client threads, and blocks them using client_control_wait within run_client. If ‘g’ is entered, I call client_control_release, which releases clients by broadcasting to waiting clients. Lastly, if a user inputs a ‘p’ command, I call db_print, which prints out the database to stdout, or to a specified textfile. If EOF is reached (ie, a user enters CTRL-D on the server side) I then proceed with cancellation, where I basically call delete_all (cancelling every thread in the client thread list), wait for the last thread to be cancelled, call db_cleanup to free the nodes in the database, cancel and join the listener thread, and exit the REPL with pthread_exit. 

There are no unsolved bugs in this program, everything (to the best of my knowledge) works as expected. 
