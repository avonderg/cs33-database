Questions

1. Consider the thread created in start_listener. How many threads with this functionality should be running on the server at any given time?

We want the server to be running multiple threads at any given point in time to allow for concurrency. This is because a multi-threaded solution is much easier to write, debug, and understand compared to one that is single-threaded. In start_listener, pthread() is called, which creates a thread executing independently of the caller. If successful, the ID is returned via the first parameter. We have the second argument set as null, and the third argument is the address of the function in which the new thread starts being executed. In this case, the function is listener(). Lastly, the third argument is the first function of the thread, that being server(). 

Since the database server for this project will be multithreaded, then a separate thread will be assigned to each client’s request. Therefore, only one thread should be running on the server at any given time-- the one created by listener, which waits for other incoming client connections. 

2. In the listener function, what do each of the following fields of the sockaddr_in struct represent: sin_family, sin_port, and sin_addr.s_addr?

In a sockaddr_in struct, the sin_family field is of type sa_family_t, and is always set to AF_INET. It represents the address family for the transport address. The sin_port field, of type in_port_t, contains the port in network-byte order. Lastly, the sin_addr field of the sockaddr_in struct is of type struct in_addr, and contains a s_addr field. So, the sin_addr field represents the IP host address, and the sin_addr.s_addr contains the host interface address, which is kept in network byte order as well. 

3. What is the purpose of each of the following function calls in listener: socket, bind, listen, and accept? You should explain what each call does and what the effect would be if it were not called.

In listener, the purpose of the socket function is to create an unbound socket within a communications domain, and to then return the file descriptor that can later be used in other function calls operating on sockets. It essentially creates a new socket descriptor. It takes in three arguments— the address family of the socket that will be created (i.e., the domain), the type of socket to create, and the protocol to be used with the socket. The first argument will always be AF_INET for standard socket programming. The second argument is SOCK_STREAM if it is a TCP socket (so, since it takes in SOCK_STREAM, it is a TCP socket). The protocol argument in this case is zero, which indicates that the default for the address family and type will be used. Thus, if it were not called, a new socket would not be created. The socket function must always be called first to perform network I/O.

Next, the bind function is called, which assigns a local protocol address to a socket. It is only called by a TCP server. Moreover, with internet protocols, the protocol address is typically either a 128-bit IPv6 address, or a 32-bit IPv4 address, and has either a 16-bit TCP or UDP port number.  Its parameters are: sockfd (the file descriptor returned by the socket function), my_addr (a pointer to the struct sockaddr_in containing the local IP address and port), and addrlen (which is always set to sizeof(struct sockaddr)). If bind is not called, then no port will be assigned by the system, and there will not be any IP address assigned either— meaning that a local socket address will not be assigned to the socket created by the socket function.

Then, the listen function is called, which is only called by a TCP server and performs the following two actions: 1) it converts an unconnected socket into a passive socket, which thus demonstrates that the kernel should be accepting any incoming connection requests directed to it, and 2) its second argument indicates the maximum number of possible connections that the kernel should queue for the socket. Thus, it indicates that the socket is ready to start accepting client requests. It takes in two parameters- sockfd (the file descriptor returned by socket), and backlog (the number of maximum connections). In this case, the maximum number of connections is 100. If listen() were to not be called, then the connection-mode socket will never be marked as accepting connections, and clients will be unable to connect to the server. Hence, no client requests would be accepted. 

Lastly, the accept function is called by the TCP server, which returns the connection that is next completed from the front of the connections queue created by listen(). This function returns a non-negative descriptor if successful which is a client-socket descriptor. All read-write operators are thus done on this descriptor in order to communicate with a client. It takes in three parameters— sockfd (the file descriptor created by socket), cliaddr (a pointer to the sockaddr_in struct containing the client’s IP address as well as its port), and addrlen (which is set to sizeof(struct sockaddr_in) for the client struct). The accept call is important as it is used by a server in order to accept a client request. Therefore, if were to not be called, the socket would be unable to begin reading data from the process that requested the connection, given that it would not be able to accept the connection request from the client. 

4. Which protocol (TCP or UDP) is used for communication? Why is this protocol used? (Hint: see line 37 in comm.c)

In the case of this project, TCP protocol is used for communication. This is because (as mentioned previously) in the socket function call, the second argument being passed in is ‘SOCK_STREAM’. The second argument of socket() is only set to this if it is a TCP socket. Thus, this implies that TCP protocol is being used for communication. TCP (transmission control protocol) is a transport protocol that is used in order to ensure that packets of data are reliably transferred. It enables application programs and devices to exchange messages over a network, as well as send packets of data cross the Internet in a reliable manner. Thus, it ensures the successful delivery of data to recipients. In the case of this project, it organizes data such that it can be sent between server and client. Before the data is sent, the protocol ensures that a connection is established between the source and destination, and that it remains live until communication begins. Larger data packets are broken up into smaller ones in order to ensure data security and integrity. 

5. Describe what comm_serve does. How are the response and command parameters used? What would happen if the stream pointed to by cxstr were closed?

Comm_serve takes in three parameters: cxstr, response, and command. Cxtstr is the file stream for the client, and response and command are two char buffers used by the program. Response is the message to be sent to the client, and command is the next command to be executed, which is sent from the client to the server. Thus, comm_serve allows for this exchange of information between client and server to take place. In each iteration, the client sends the command (via ‘command’), and the server sends the response (via ‘response’), and the client sends a command back. 
	
If the stream pointed to by cxstr were to be closed, then the function will error and return -1, thus indicating that the client connection would be terminated. Therefore, if the stream is closed, the client connection terminates. 

6. Describe, in detail, what happens during each iteration of the while loop in the listener function. Be sure to include explanations of all significant function calls.

The listener thread is created by the main server program. When a client connects to a server, the listener function will execute all of the commands within the while loop. Within the loop, the accept function is first called, which returns the connection that is next completed from the front of the connections queue created by listen(), and returns a non-negative descriptor (if successful) which is a client-socket descriptor (assigned to csock). All read-write operators are done on csock in order to communicate with a client. Accept takes in the socket file descriptor, a pointer to the sockaddr_in struct containing the client’s IP address as well as its port, and the size of the client sockaddr_in struct. If the call to accept is successful, the function prints out to stderr that a connection was received, and opens the file stream for the client by calling fdopen on csock. Fdopen essentially opens the file indicated by csock for reading and writing (as indicated by ‘w+’ which is passed in). This allows for read-write operations to be done on csock, allowing for the server to communicate with the client. Lastly, server() (the function passed in as an argument to listener) is called on the file pointer returned by fdopen (cxstr), so that the server will create a socket with the file stream (cxstr) that is passed in. The server thus essentially creates a new client thread. In summary, with the while loop, the server essentially just waits for connections, and every time a pending one comes through, it sets up the client and server connection. and, when a client connects, the listener function then executes the commands within the loop.


